#include <core\CTConstant.h>

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTVec2<Tx> - 连续存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::clear(Tx* in)
{
	in[0] = in[1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::clear(Tx* in,
										 int index)
{
	in[index * 2] = in[index * 2 + 1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx x,
										 Tx y,
										 Tx* in_result)
{
	in_result[0] = x;
	in_result[1] = y;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx* in,
										 Tx* result)
{
	result[0] = in[0];
	result[1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx in_x,
										 Tx in_y,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in_x;
	result[result_index * 2 + 1] = in_y;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx* in,
										 int in_index,
										 Tx* result)
{
	result[0] = in[in_index * 2];
	result[1] = in[in_index * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx* in,
										 int in_index,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in[in_index * 2];
	result[result_index * 2 + 1] = in[in_index * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::equal(Tx* in,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in[0];
	result[result_index * 2 + 1] = in[1];
}

template <typename Tx>
bool CppTools::CTMath::CTVec2<Tx>::isEqual(Tx* first,
										   Tx* second,
										   Tx err)
{
	if(!err)
	{
		if((first[0] == second[0]) && (first[1] == second[1]))
			return true;
		return false;
	}
	else
	{
		if((Abs(first[0] - second[0]) < Abs(err)) && (Abs(first[1] - second[1]) < Abs(err)))
			return true;
		return false;
	}
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::add(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTVec2<Tx>::equal(first[0] + second[0], first[1] + second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::add(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 2] = first[index_1 * 2] + second[index_2 * 2];
	result[result_index * 2 + 1] = first[index_1 * 2 + 1] + second[index_2 * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::sub(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTVec2<Tx>::equal(first[0] - second[0], first[1] - second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::sub(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 2] = first[index_1 * 2] - second[index_2 * 2];
	result[result_index * 2 + 1] = first[index_1 * 2 + 1] - second[index_2 * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::reverse(Tx* in)
{
	in[0] = -in[0];
	in[1] = -in[1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::reverse(Tx* in,
										   int index)
{
	in[index * 2] = -in[index * 2];
	in[index * 2 + 1] = -in[index * 2 + 1];
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::dot(Tx* first,
									 Tx* second)
{
	return (first[0] * second[0] + first[1] * second[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::dot(Tx* first,
									 int index_1,
									 Tx* second,
									 int index_2)
{
	return (first[index_1 * 2] * second[index_2 * 2] + first[index_1 * 2 + 1] * second[index_2 * 2 + 1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::module(Tx* in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::module(Tx* in,
										int index)
{
	return sqrt(in[index * 2] * in[index * 2] + in[index * 2 + 1] * in[index * 2 + 1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::angle(Tx* first,
									   Tx* second)
{
	return acos(CTVec2<Tx>::dot(first, second) / (CTVec2<Tx>::module(first) * CTVec2<Tx>::module(second)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2<Tx>::angle(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2)
{
	return acos(CTVec2<Tx>::dot(first, index_1, second, index_2) / (CTVec2<Tx>::module(first, index_1) * CTVec2<Tx>::module(second, index_2)));
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::normalize(Tx* in)
{
	Tx m = CTVec2<Tx>::module(in);
	CTVec2<Tx>::equal(in[0] / m, in[1] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::normalize(Tx* in,
											 int index)
{
	Tx m = CTVec2<Tx>::module(in, index);
	CTVec2<Tx>::equal(in[index * 2] / m, in[index * 2 + 1] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::print(Tx* in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::print(Tx* in,
										 int index)
{
	std::cout<<"("
		<<in[index * 2]<<","
		<<in[index * 2 + 1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec2<Tx>::printAll(Tx* in,
											int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTVec2<Tx>::print(in, i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTVec2v<Tx> - 2元存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::clear(vec2 in)
{
	in[0] = in[1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::clear(vec2* in,
										  int index)
{
	in[index][0] = in[index][1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::equal(Tx x,
										  Tx y,
										  vec2 in_result)
{
	in_result[0] = x;
	in_result[1] = y;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::equal(vec2 in,
										  vec2 result)
{
	result[0] = in[0];
	result[1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::equal(Tx in_x,
										  Tx in_y,
										  vec2* result,
										  int result_index)
{
	result[result_index][0] = in_x;
	result[result_index][1] = in_y;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::equal(vec2 in,
										  vec2* result,
										  int result_index)
{
	result[result_index][0] = in[0];
	result[result_index][1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::equal(vec2* in,
										  int in_index,
										  vec2* result,
										  int result_index)
{
	result[result_index][0] = in[in_index][0];
	result[result_index][1] = in[in_index][1];
}

template <typename Tx>
bool CppTools::CTMath::CTVec2v<Tx>::isEqual(vec2 first,
											vec2 second,
											Tx err)
{
	if(!err)
	{
		if((first[0] == second[0]) && (first[1] == second[1]))
			return true;
		return false;
	}
	else
	{
		if((Abs(first[0] - second[0]) < Abs(err)) && (Abs(first[1] - second[1]) < Abs(err)))
			return true;
		return false;
	}
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::add(vec2 first,
										vec2 second,
										vec2 result)
{
	CTVec2v<Tx>::equal(first[0] + second[0], first[1] + second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::add(vec2* first,
										int index_1,
										vec2* second,
										int index_2,
										vec2* result,
										int result_index)
{
	result[result_index][0] = first[index_1][0] + second[index_2][0];
	result[result_index][1] = first[index_1][1] + second[index_2][1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::sub(vec2 first,
										vec2 second,
										vec2 result)
{
	CTVec2v<Tx>::equal(first[0] - second[0], first[1] - second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::sub(vec2* first,
										int index_1,
										vec2* second,
										int index_2,
										vec2* result,
										int result_index)
{
	result[result_index][0] = first[index_1][0] - second[index_2][0];
	result[result_index][1] = first[index_1][1] - second[index_2][1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::reverse(vec2 in)
{
	in[0] = -in[0];
	in[1] = -in[1];
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::reverse(vec2* in,
											int index)
{
	in[index][0] = -in[index][0];
	in[index][1] = -in[index][1];
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::dot(vec2 first,
									  vec2 second)
{
	return (first[0] * second[0] + first[1] * second[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::dot(vec2* first,
									  int index_1,
									  vec2* second,
									  int index_2)
{
	return (first[index_1][0] * second[index_2][0] + first[index_1][1] * second[index_2][1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::module(vec2 in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::module(vec2* in,
										 int index)
{
	return sqrt(in[index][0] * in[index][0] + in[index][1] * in[index][1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::angle(vec2 first,
										vec2 second)
{
	return acos(CTVec2v<Tx>::dot(first, second) / (CTVec2v<Tx>::module(first) * CTVec2v<Tx>::module(second)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec2v<Tx>::angle(vec2* first,
										int index_1,
										vec2* second,
										int index_2)
{
	return acos(CTVec2v<Tx>::dot(first, index_1, second, index_2) / (CTVec2v<Tx>::module(first, index_1) * CTVec2v<Tx>::module(second, index_2)));
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::normalize(vec2 in)
{
	Tx m = CTVec2v<Tx>::module(in);
	CTVec2v<Tx>::equal(in[0] / m, in[1] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::normalize(vec2* in, int index)
{
	Tx m = CTVec2v<Tx>::module(in, index);
	CTVec2v<Tx>::equal(in[index][0] / m, in[index][1] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::print(vec2 in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::print(vec2* in,
										  int index)
{
	std::cout<<"("
		<<in[index][0]<<","
		<<in[index][1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec2v<Tx>::printAll(vec2* in,
											 int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTVec2v<Tx>::print(in, i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTVec3<Tx> - 连续存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::clear(Tx* in)
{
	in[0] = in[1] = in[2] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::clear(Tx* in,
										 int index)
{
	in[index * 3] = in[index * 3 + 1] = in[index * 3 + 2] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx x,
										 Tx y,
										 Tx z,
										 Tx* in_result)
{
	in_result[0] = x;
	in_result[1] = y;
	in_result[2] = z;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx* in,
										 Tx* result)
{
	result[0] = in[0];
	result[1] = in[1];
	result[2] = in[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx in_x,
										 Tx in_y,
										 Tx in_z,
										 Tx* result,
										 int result_index)
{
	result[result_index * 3] = in_x;
	result[result_index * 3 + 1] = in_y;
	result[result_index * 3 + 2] = in_z;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx* in,
										 int index,
										 Tx* result)
{
	result[0] = in[index * 3];
	result[1] = in[index * 3 + 1];
	result[2] = in[index * 3 + 2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx* in,
										 int in_index,
										 Tx* result,
										 int result_index)
{
	result[result_index * 3] = in[in_index * 3];
	result[result_index * 3 + 1] = in[in_index * 3 + 1];
	result[result_index * 3 + 2] = in[in_index * 3 + 2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equal(Tx* in,
										 Tx* result,
										 int result_index)
{
	result[result_index * 3] = in[0];
	result[result_index * 3 + 1] = in[1];
	result[result_index * 3 + 2] = in[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::equalv(const Tx* in,
										  const int index,
										  vec3 result)
{
	result[0] = in[index * 3];
	result[1] = in[index * 3 + 1];
	result[2] = in[index * 3 + 2];
}

template <typename Tx>
bool CppTools::CTMath::CTVec3<Tx>::isEqual(Tx* first,
										   Tx* second,
										   Tx err)
{
	if(!err)
	{
		if((first[0] == second[0])
			&& (first[1] == second[1])
			&& (first[2] == second[2]))
			return true;
		return false;
	}
	else
	{
		if((CppTools::Abs(first[0] - second[0]) < CppTools::Abs(err))
			&& (CppTools::Abs(first[1] - second[1]) < CppTools::Abs(err))
			&& (CppTools::Abs(first[2] - second[2]) < CppTools::Abs(err)))
			return true;
		return false;
	}
}

template <typename Tx>
bool CppTools::CTMath::CTVec3<Tx>::isSymmetry0(Tx* first,
											   Tx* second)
{
	vec3 t1, t2;
	CppTools::CTMath::CTVec3<Tx>::equal(first, t1);
	CppTools::CTMath::CTVec3<Tx>::normalize(t1);
	CppTools::CTMath::CTVec3<Tx>::equal(second, t2);
	CppTools::CTMath::CTVec3<Tx>::normalize(t2);
	if((t1[0] == -t2[0])
		&& (t1[1] == -t2[1])
		&& (t1[2] == -t2[2]))
		return true;
	return false;
}

template <typename Tx>
bool CppTools::CTMath::CTVec3<Tx>::isSymmetryXoY(Tx* first,
												 Tx* second)
{
	vec3 t1, t2;
	CppTools::CTMath::CTVec3<Tx>::equal(first, t1);
	CppTools::CTMath::CTVec3<Tx>::normalize(t1);
	CppTools::CTMath::CTVec3<Tx>::equal(second, t2);
	CppTools::CTMath::CTVec3<Tx>::normalize(t2);
	if((t1[0] == t2[0])
		&& (t1[1] == t2[1])
		&& (t1[2] == -t2[2]))
		return true;
	return false;
}

template <typename Tx>
bool CppTools::CTMath::CTVec3<Tx>::isSymmetryYoZ(Tx* first,
												 Tx* second)
{
	vec3 t1, t2;
	CppTools::CTMath::CTVec3<Tx>::equal(first, t1);
	CppTools::CTMath::CTVec3<Tx>::normalize(t1);
	CppTools::CTMath::CTVec3<Tx>::equal(second, t2);
	CppTools::CTMath::CTVec3<Tx>::normalize(t2);
	if((t1[0] == -t2[0])
		&& (t1[1] == t2[1])
		&& (t1[2] == t2[2]))
		return true;
	return false;
}

template <typename Tx>
bool CppTools::CTMath::CTVec3<Tx>::isSymmetryXoZ(Tx* first,
												 Tx* second)
{
	vec3 t1, t2;
	CppTools::CTMath::CTVec3<Tx>::equal(first, t1);
	CppTools::CTMath::CTVec3<Tx>::normalize(t1);
	CppTools::CTMath::CTVec3<Tx>::equal(second, t2);
	CppTools::CTMath::CTVec3<Tx>::normalize(t2);
	if((t1[0] == t2[0])
		&& (t1[1] == -t2[1])
		&& (t1[2] == t2[2]))
		return true;
	return false;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::add(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTVec3<Tx>::equal(first[0] + second[0], first[1] + second[1], first[2] + second[2], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::add(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 3] = first[index_1 * 3] + second[index_2 * 3];
	result[result_index * 3 + 1] = first[index_1 * 3 + 1] + second[index_2 * 3 + 1];
	result[result_index * 3 + 2] = first[index_1 * 3 + 2] + second[index_2 * 3 + 2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::add(Tx* first,
									   int index_1,
									   Tx* second,
									   Tx* result)
{
	result[0] = first[index_1 * 3] + second[0];
	result[1] = first[index_1 * 3 + 1] + second[1];
	result[2] = first[index_1 * 3 + 2] + second[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::sub(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTVec3<Tx>::equal(first[0] - second[0], first[1] - second[1], first[2] - second[2], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::sub(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 3] = first[index_1 * 3] - second[index_2 * 3];
	result[result_index * 3 + 1] = first[index_1 * 3 + 1] - second[index_2 * 3 + 1];
	result[result_index * 3 + 2] = first[index_1 * 3 + 2] - second[index_2 * 3 + 2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::reverse(Tx* in)
{
	in[0] = -in[0];
	in[1] = -in[1];
	in[2] = -in[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::reverse(Tx* in,
										   int index)
{
	in[index * 3] = -in[index * 3];
	in[index * 3 + 1] = -in[index * 3 + 1];
	in[index * 3 + 2] = -in[index * 3 + 2];
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::dot(Tx* first,
									 Tx* second)
{
	return (first[0] * second[0] + first[1] * second[1] + first[2] * second[2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::dot(Tx* first,
									 int index_1,
									 Tx* second,
									 int index_2)
{
	return (first[index_1 * 3] * second[index_2 * 3] + first[index_1 * 3 + 1] * second[index_2 * 3 + 1] + first[index_1 * 3 + 2] * second[index_2 * 3 + 2]);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::cross(Tx* first,
										 Tx* second,
										 Tx* result)
{
	CTVec3<Tx>::equal(first[1] * second[2] - second[1] * first[2],
		first[2] * second[0] - second[2] * first[0],
		first[0] * second[1] - second[0] * first[1],
		result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::cross(Tx* first,
										 int index_1,
										 Tx* second,
										 int index_2,
										 Tx* result)
{
	CTVec3<Tx>::equal(first[index_1 * 3 + 1] * second[index_2 * 3 + 2] - second[index_2 * 3 + 1] * first[index_1 * 3 + 2],
		first[index_1 * 3 + 2] * second[index_2 * 3] - second[index_2 * 3 + 2] * first[index_1 * 3],
		first[index_1 * 3] * second[index_2 * 3 + 1] - second[index_2 * 3] * first[index_1 * 3 + 1],
		result);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::module(Tx* in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1] + in[2] * in[2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::module(Tx* in,
										int index)
{
	return sqrt(in[index * 3] * in[index * 3] + in[index * 3 + 1] * in[index * 3 + 1] + in[index * 3 + 2] * in[index * 3 + 2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::angle(Tx* first,
									   Tx* second)
{
	return acos(CTVec3<Tx>::dot(first, second) / (CTVec3<Tx>::module(first) * CTVec3<Tx>::module(second)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::angle(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2)
{
	return acos(CTVec3<Tx>::dot(first, index_1, second, index_2) / (CTVec3<Tx>::module(first, index_1) * CTVec3<Tx>::module(second, index_2)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::angle_x(Tx* in)
{
	if(!in[0])
	{
		if(in[1] < 0)
			return (Tx)(-ct_pi/4.0);
		else
			return (Tx)(ct_pi/4.0);
	}
	return atan(in[1] / in[0]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::angle_z(Tx* in)
{
	return acos(in[2] / CTVec3<Tx>::module(in));
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::normalize(Tx* in)
{
	Tx m = CTVec3<Tx>::module(in);
	CTVec3<Tx>::equal(in[0] / m, in[1] / m, in[2] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::normalize(Tx* in,
											 int index)
{
	Tx m = CTVec3<Tx>::module(in, index);
	CTVec3<Tx>::equal(in[index * 3] / m, in[index * 3 + 1] / m, in[index * 3 + 2] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::localSystem(Tx* in,
											   Tx* local_z,
											   Tx* result_local_x,
											   Tx* result_local_y)
{
	Tx ki[3];
	Tx thi, fri;
	thi = CTVec3<Tx>::angle_z(in);
	fri = CTVec3<Tx>::angle_x(in);
	CTVec3<Tx>::equal(sin(thi) * cos(fri),
		sin(thi) * sin(fri),
		-cos(thi),
		ki);
	CTVec3<Tx>::normalize(local_z);
	CTVec3<Tx>::cross(local_z, ki, result_local_y);
	CTVec3<Tx>::normalize(result_local_y);
	CTVec3<Tx>::cross(result_local_y, local_z, result_local_x);
	CTVec3<Tx>::normalize(result_local_x);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::projectSystem(Tx* local_x,
												 Tx* local_y,
												 Tx* local_z,
												 Tx* result_a,
												 Tx* result_b)
{
	Tx thi, fri;
	Tx sinthi, costhi, sinfri, cosfri;
	thi = CTVec3<Tx>::angle_z(local_z);
	fri = CTVec3<Tx>::angle_x(local_z);
	sinthi = sin(thi);
	costhi = cos(thi);
	sinfri = sin(fri);
	cosfri = cos(fri);
	CTVec3<Tx>::equal(-(local_z[1] * costhi + local_z[2] * sinthi * sinfri),
		(local_z[0] * costhi + local_z[2] * sinthi * cosfri),
		(local_z[0] * sinthi * sinfri - local_z[1] * sinthi * cosfri),
		result_b);
	CTVec3<Tx>::normalize(result_b);
	CTVec3<Tx>::equal((result_b[1] * local_z[2] - result_b[2] * local_z[1]),
		(result_b[2] * local_z[0] - result_b[0] * local_z[2]),
		(result_b[0] * local_z[1] - result_b[1] * local_z[0]),
		result_a);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::project(Tx* a,
										   Tx* b,
										   Tx* n,
										   Tx* in,
										   Tx* result)
{
	CTVec3<Tx>::equal((a[0] * in[0] + a[1] * in[1] + a[2] * in[2]),
		(b[0] * in[0] + b[1] * in[1] + b[2] * in[2]),
		(n[0] * in[0] + n[1] * in[1] + n[2] * in[2]),
		result);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::theta(Tx* in)
{
	Tx t;
	t = sqrt(in[0] * in[0] + in[1] * in[1]);
	return acos(t / in[2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3<Tx>::phi(Tx* in)
{
	if(!in[0])
	{
		if(in[1] < 0)
			return (Tx)(-ct_pi/4.0);
		else
			return (Tx)(ct_pi/4.0);
	}
	return atan(in[1] / in[0]);
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::print(Tx* in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]<<","
		<<in[2]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::print(Tx* in,
										 int index)
{
	std::cout<<"("
		<<in[index * 3]<<","
		<<in[index * 3 + 1]<<","
		<<in[index * 3 + 2]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec3<Tx>::printAll(Tx* in,
											int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTVec3<Tx>::print(in, i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTVec3v<Tx> - 3元存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::clear(vec3 in)
{
	in[0] = in[1] = in[2] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::clear(vec3* in,
										  const int index)
{
	in[index][0] = in[index][1] = in[index][2] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::equal(const Tx x,
										  const Tx y,
										  const Tx z,
										  vec3 in_result)
{
	in_result[0] = x;
	in_result[1] = y;
	in_result[2] = z;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::equal(const vec3 in,
										  vec3 result)
{
	result[0] = in[0];
	result[1] = in[1];
	result[2] = in[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::equal(const Tx in_x,
										  const Tx in_y,
										  const Tx in_z,
										  vec3* result,
										  const int result_index)
{
	result[result_index][0] = in_x;
	result[result_index][1] = in_y;
	result[result_index][2] = in_z;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::equal(const vec3* in,
										  const int in_index,
										  vec3* result,
										  const int result_index)
{
	result[result_index][0] = in[in_index][0];
	result[result_index][1] = in[in_index][1];
	result[result_index][2] = in[in_index][2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::equal(const vec3 in,
										  vec3* result,
										  const int result_index)
{
	result[result_index][0] = in[0];
	result[result_index][1] = in[1];
	result[result_index][2] = in[2];
}

template <typename Tx>
bool CppTools::CTMath::CTVec3v<Tx>::isEqual(vec3 first,
											vec3 second,
											Tx err)
{
	if(!err)
	{
		if((first[0] == second[0]) && (first[1] == second[1]) && (first[2] == second[2]))
			return true;
		return false;
	}
	else
	{
		if((Abs(first[0] - second[0]) < Abs(err)) && (Abs(first[1] - second[1]) < Abs(err)) && (Abs(first[2] - second[2]) < Abs(err)))
			return true;
		return false;
	}
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::add(const vec3 first,
										const vec3 second,
										vec3 result)
{
	CTVec3v<Tx>::equal(first[0] + second[0], first[1] + second[1], first[2] + second[2], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::add(const vec3* first,
										const int index_1,
										const vec3* second,
										const int index_2,
										vec3* result,
										const int result_index)
{
	result[result_index][0] = first[index_1][0] + second[index_2][0];
	result[result_index][1] = first[index_1][1] + second[index_2][1];
	result[result_index][2] = first[index_1][2] + second[index_2][2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::sub(const vec3 first,
										const vec3 second,
										vec3 result)
{
	CTVec3v<Tx>::equal(first[0] - second[0], first[1] - second[1], first[2] - second[2], result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::sub(const vec3* first,
										const int index_1,
										const vec3* second,
										const int index_2,
										vec3* result,
										const int result_index)
{
	result[result_index][0] = first[index_1][0] - second[index_2][0];
	result[result_index][1] = first[index_1][1] - second[index_2][1];
	result[result_index][2] = first[index_1][2] - second[index_2][2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::reverse(vec3 in)
{
	in[0] = -in[0];
	in[1] = -in[1];
	in[2] = -in[2];
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::reverse(vec3* in,
											const int index)
{
	in[index][0] = -in[index][0];
	in[index][1] = -in[index][1];
	in[index][2] = -in[index][2];
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::dot(const vec3 first,
									  const vec3 second)
{
	return (first[0] * second[0] + first[1] * second[1] + first[2] * second[2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::dot(const vec3* first,
									  const int index_1,
									  const vec3* second,
									  const int index_2)
{
	return (first[index_1][0] * second[index_2][0] + first[index_1][1] * second[index_2][1] + first[index_1][2] * second[index_2][2]);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::cross(const vec3 first,
										  const vec3 second,
										  vec3 result)
{
	CTVec3v<Tx>::equal(first[1] * second[2] - second[1] * first[2],
		first[2] * second[0] - second[2] * first[0],
		first[0] * second[1] - second[0] * first[1],
		result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::cross(const vec3* first,
										  const int index_1,
										  const vec3* second,
										  const int index_2,
										  vec3* result)
{
	CTVec3v<Tx>::equal(first[index_1][1] * second[index_2][2] - second[index_2][1] * first[index_1][2],
		first[index_1][2] * second[index_2][0] - second[index_2][2] * first[index_1][0],
		first[index_1][0] * second[index_2][1] - second[index_2][0] * first[index_1][1],
		result);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::module(const vec3 in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1] + in[2] * in[2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::module(const vec3* in,
										 const int index)
{
	return sqrt(in[index][0] * in[index][0] + in[index][1] * in[index][1] + in[index][2] * in[index][2]);
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle(const vec3 first,
										const vec3 second)
{
	return acos(CTVec3v<Tx>::dot(first, second) / (CTVec3<Tx>::module(first) * CTVec3v<Tx>::module(second)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle(const vec3* first,
										const int index_1,
										const vec3* second,
										const int index_2)
{
	return acos(CTVec3v<Tx>::dot(first, index_1, second, index_2) / (CTVec3v<Tx>::module(first, index_1) * CTVec3v<Tx>::module(second, index_2)));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_x(const vec3 in)
{
	return acos(in[0] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_y(const vec3 in)
{
	return acos(in[1] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_z(const vec3 in)
{
	return acos(in[2] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_XoY(const vec3 in)
{
	return Sig<Tx>(in[2]) * asin(in[2] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_XoZ(const vec3 in)
{
	return Sig<Tx>(in[1]) * asin(in[1] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_YoZ(const vec3 in)
{
	return Sig<Tx>(in[0]) * asin(in[0] / CTVec3v<Tx>::module(in));
}

template <typename Tx>
Tx CppTools::CTMath::CTVec3v<Tx>::angle_XoY_x(const vec3 in)
{
	if(in[1] >= 0)
		return acos(in[0] / sqrt(CTCalculate<Tx>::sumOfSquares(in[0], in[1])));
	else
		return (Tx)2.0 * (Tx)CT_PI - acos(in[0] / sqrt(CTCalculate<Tx>::sumOfSquares(in[0], in[1])));
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::normalize(vec3 in)
{
	Tx m = CTVec3v<Tx>::module(in);
	CTVec3v<Tx>::equal(in[0] / m, in[1] / m, in[2] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::normalize(vec3* in,
											  const int index)
{
	Tx m = CTVec3v<Tx>::module(in, index);
	CTVec3v<Tx>::equal(in[index * 3] / m, in[index * 3 + 1] / m, in[index * 3 + 2] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::localSystem(const Tx thi,
												const Tx fri,
												const vec3 local_z,
												vec3 result_local_x,
												vec3 result_local_y)
{
	vec3 ki, loc_z;
	CTVec3v<Tx>::equal(sin(thi) * cos(fri),
		sin(thi) * sin(fri),
		-cos(thi),
		ki);
	CTVec3v<Tx>::equal(local_z, loc_z);
	CTVec3v<Tx>::normalize(loc_z);
	CTVec3v<Tx>::cross(loc_z, ki, result_local_y);
	CTVec3v<Tx>::normalize(result_local_y);
	CTVec3v<Tx>::cross(result_local_y, loc_z, result_local_x);
	CTVec3v<Tx>::normalize(result_local_x);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::localSystem(const vec3 in,
												const vec3 local_z,
												vec3 result_local_x,
												vec3 result_local_y)
{
	localSystem(CTVec3v<Tx>::angle_z(in), CTVec3v<Tx>::angle_XoY_x(in), local_z, result_local_x, result_local_y);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::projectSystem(const vec3 local_x,
												  const vec3 local_y,
												  const vec3 local_z,
												  vec3 result_a,
												  vec3 result_b)
{
	Tx thi, fri;
	Tx sinthi, costhi, sinfri, cosfri;
	thi = CTVec3v<Tx>::angle_z(local_z);
	fri = CTVec3v<Tx>::angle_XoY_x(local_z);
	sinthi = sin(thi);
	costhi = cos(thi);
	sinfri = sin(fri);
	cosfri = cos(fri);
	CTVec3v<Tx>::equal(-(local_z[1] * costhi + local_z[2] * sinthi * sinfri),
		(local_z[0] * costhi + local_z[2] * sinthi * cosfri),
		(local_z[0] * sinthi * sinfri - local_z[1] * sinthi * cosfri),
		result_b);
	CTVec3v<Tx>::normalize(result_b);
	CTVec3v<Tx>::equal((result_b[1] * local_z[2] - result_b[2] * local_z[1]),
		(result_b[2] * local_z[0] - result_b[0] * local_z[2]),
		(result_b[0] * local_z[1] - result_b[1] * local_z[0]),
		result_a);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::project(const vec3 a,
											const vec3 b,
											const vec3 n,
											const vec3 in,
											vec3 result)
{
	CTVec3v<Tx>::equal((a[0] * in[0] + a[1] * in[1] + a[2] * in[2]),
		(b[0] * in[0] + b[1] * in[1] + b[2] * in[2]),
		(n[0] * in[0] + n[1] * in[1] + n[2] * in[2]),
		result);
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::print(const vec3 in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]<<","
		<<in[2]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::print(const vec3* in,
										  const int index)
{
	std::cout<<"("
		<<in[index][0]<<","
		<<in[index][1]<<","
		<<in[index][2]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTVec3v<Tx>::printAll(const vec3* in,
											 const int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTVec3v<Tx>::print(in, i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTCplx<Tx> - 连续存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::clear(Tx* in)
{
	in[0] = in[1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::clear(Tx* in,
										 int index)
{
	in[index * 2] = in[index * 2 + 1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::equal(Tx real,
										 Tx image,
										 Tx* in_result)
{
	in_result[0] = real;
	in_result[1] = image;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::equal(Tx* in,
										 Tx* result)
{
	result[0] = in[0];
	result[1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::equal(Tx in_real,
										 Tx in_image,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in_real;
	result[result_index * 2 + 1] = in_image;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::equal(Tx* in,
										 int in_index,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in[in_index * 2];
	result[result_index * 2 + 1] = in[in_index * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::equal(Tx* in,
										 Tx* result,
										 int result_index)
{
	result[result_index * 2] = in[0];
	result[result_index * 2 + 1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::add(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTCplx<Tx>::equal(first[0] + second[0], first[1] + second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::add(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 2] = first[index_1 * 2] + second[index_2 * 2];
	result[result_index * 2 + 1] = first[index_1 * 2 + 1] + second[index_2 * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::sub(Tx* first,
									   Tx* second,
									   Tx* result)
{
	CTCplx<Tx>::equal(first[0] - second[0], first[1] - second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::sub(Tx* first,
									   int index_1,
									   Tx* second,
									   int index_2,
									   Tx* result,
									   int result_index)
{
	result[result_index * 2] = first[index_1 * 2] - second[index_2 * 2];
	result[result_index * 2 + 1] = first[index_1 * 2 + 1] - second[index_2 * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::reverse(Tx* in)
{
	in[0] = -in[0];
	in[1] = -in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::reverse(Tx* in,
										   int index)
{
	in[index * 2] = -in[index * 2];
	in[index * 2 + 1] = -in[index * 2 + 1];
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::multiply(Tx* first,
											Tx* second,
											Tx* result)
{
	CTCplx<Tx>::equal((first[0] * second[0] - first[1] * second[1]), (first[0] * second[1] + first[1] * second[0]), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::multiply(Tx* first,
											int index_1,
											Tx* second,
											int index_2,
											Tx* result)
{
	CTCplx<Tx>::equal((first[index_1 * 2] * second[index_2 * 2] - first[index_1 * 2 + 1] * second[index_2 * 2 + 1]),
		(first[index_1 * 2] * second[index_2 * 2 + 1] + first[index_1 * 2 + 1] * second[index_2 * 2]),
		result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::exp(Tx exponent,
									   Tx* result)
{
	CTCplx<Tx>::equal(cos(exponent), sin(exponent), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::exp(Tx* in,
									   Tx* result)
{
	CTCplx<Tx>::equal(exp(in[0]) * cos(in[1]), exp(in[0]) * sin(in[1]), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::exp(Tx* in,
									   int in_index,
									   Tx* result,
									   int result_index)
{
	CTCplx<Tx>::equal(exp(in[in_index * 2]) * cos(in[in_index * 2 + 1]), exp(in[in_index * 2]) * sin(in[in_index * 2 + 1]), result, result_index);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::conjugate(Tx* in,
											 Tx* result)
{
	CTCplx<Tx>::equal(in[0], -in[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::conjugate(Tx* in,
											 int in_index,
											 Tx* result,
											 int result_index)
{
	CTCplx<Tx>::equal(in[in_index * 2], -in[in_index * 2 + 1], result, result_index);
}

template <typename Tx>
Tx CppTools::CTMath::CTCplx<Tx>::module(Tx* in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTCplx<Tx>::module(Tx* in,
										int index)
{
	return sqrt(in[index * 2] * in[index * 2] + in[index * 2 + 1] * in[index * 2 + 1]);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::normalize(Tx* in)
{
	Tx m = CTCplx<Tx>::module(in);
	CTCplx<Tx>::equal(in[0] / m, in[1] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::normalize(Tx* in,
											 int index)
{
	Tx m = CTCplx<Tx>::module(in, index);
	CTCplx<Tx>::equal(in[index * 2] / m, in[index * 2 + 1] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::print(Tx* in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::print(Tx* in,
										 int index)
{
	std::cout<<"("
		<<in[index * 2]<<","
		<<in[index * 2 + 1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTCplx<Tx>::printAll(Tx* in,
											int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTCplx<Tx>::print(in, i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//CTCplxv<Tx> - 2元存储方式
///////////////////////////////////////////////////////////////////////////////////////////////////

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::clear(cplx in)
{
	in[0] = in[1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::clear(cplx* in,
										  int index)
{
	in[index][0] = in[index][1] = 0;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::equal(Tx real,
										  Tx image,
										  cplx in_result)
{
	in_result[0] = real;
	in_result[1] = image;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::equal(cplx in,
										  cplx result)
{
	result[0] = in[0];
	result[1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::equal(Tx in_real,
										  Tx in_image,
										  cplx* result,
										  int result_index)
{
	result[result_index][0] = in_real;
	result[result_index][1] = in_image;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::equal(cplx in,
										  cplx* result,
										  int result_index)
{
	result[result_index][0] = in[0];
	result[result_index][1] = in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::equal(cplx* in,
										  int in_index,
										  cplx* result,
										  int result_index)
{
	result[result_index][0] = in[in_index][0];
	result[result_index][1] = in[in_index][1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::add(cplx first,
										cplx second,
										cplx result)
{
	CTCplxv<Tx>::equal(first[0] + second[0], first[1] + second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::add(cplx* first,
										int index_1,
										cplx* second,
										int index_2,
										cplx* result,
										int result_index)
{
	result[result_index][0] = first[index_1][0] + second[index_2][0];
	result[result_index][1] = first[index_1][1] + second[index_2][1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::sub(cplx first,
										cplx second,
										cplx result)
{
	CTCplxv<Tx>::equal(first[0] - second[0], first[1] - second[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::sub(cplx* first,
									   int index_1,
									   cplx* second,
									   int index_2,
									   cplx* result,
									   int result_index)
{
	result[result_index][0] = first[index_1][0] - second[index_2][0];
	result[result_index][1] = first[index_1][1] - second[index_2][1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::reverse(cplx in)
{
	in[0] = -in[0];
	in[1] = -in[1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::reverse(cplx* in,
											int index)
{
	in[index][0] = -in[index][0];
	in[index][1] = -in[index][1];
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::multiply(cplx first,
											 cplx second,
											 cplx result)
{
	CTCplxv<Tx>::equal((first[0] * second[0] - first[1] * second[1]), (first[0] * second[1] + first[1] * second[0]), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::multiply(cplx* first,
											 int index_1,
											 cplx* second,
											 int index_2,
											 cplx result)
{
	CTCplx<Tx>::equal((first[index_1][0] * second[index_2][0] - first[index_1][1] * second[index_2][1]),
		(first[index_1][0] * second[index_2][1] + first[index_1][1] * second[index_2][0]),
		result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::exp(Tx exponent,
										cplx result)
{
	CTCplxv<Tx>::equal(cos(exponent), sin(exponent), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::exp(cplx in,
										cplx result)
{
	CTCplxv<Tx>::equal(exp(in[0]) * cos(in[1]), exp(in[0]) * sin(in[1]), result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::exp(cplx* in,
										int in_index,
										cplx* result,
										int result_index)
{
	CTCplxv<Tx>::equal(exp(in[in_index * 2]) * cos(in[in_index * 2 + 1]), exp(in[in_index * 2]) * sin(in[in_index * 2 + 1]), result, result_index);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::conjugate(cplx in,
											 cplx result)
{
	CTCplxv<Tx>::equal(in[0], -in[1], result);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::conjugate(cplx* in,
											  int in_index,
											  cplx* result,
											  int result_index)
{
	CTCplxv<Tx>::equal(in[in_index * 2], -in[in_index * 2 + 1], result, result_index);
}

template <typename Tx>
Tx CppTools::CTMath::CTCplxv<Tx>::module(cplx in)
{
	return sqrt(in[0] * in[0] + in[1] * in[1]);
}

template <typename Tx>
Tx CppTools::CTMath::CTCplxv<Tx>::module(cplx* in,
										 int index)
{
	return sqrt(in[index * 2] * in[index * 2] + in[index * 2 + 1] * in[index * 2 + 1]);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::normalize(cplx in)
{
	Tx m = CTCplxv<Tx>::module(in);
	CTCplxv<Tx>::equal(in[0] / m, in[1] / m, in);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::normalize(cplx* in,
											  int index)
{
	Tx m = CTCplxv<Tx>::module(in, index);
	CTCplxv<Tx>::equal(in[index * 2] / m, in[index * 2 + 1] / m, in, index);
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::print(cplx in)
{
	std::cout<<"("
		<<in[0]<<","
		<<in[1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::print(cplx* in,
										  int index)
{
	std::cout<<"("
		<<in[index * 2]<<","
		<<in[index * 2 + 1]
	<<")"<<endl;
}

template <typename Tx>
void CppTools::CTMath::CTCplxv<Tx>::printAll(cplx* in,
											 int num)
{
	int i;
	for(i = 0; i < num; ++i)
		CTCplxv<Tx>::print(in, i);
}

//随机数

template <typename Tx>
Tx CppTools::CTMath::RandomGauss()
{
	Tx u1 = Random<Tx>();
	if (u1 < 1e-6)
		u1 = 1e-6;
	return sqrt(-2 * log(u1)) * cos(2 * ct_pi * Random<Tx>());
}

//计算类CTCalculate

template <typename Tx>
bool CppTools::CTMath::CTCalculate<Tx>::isNaN(const Tx num)
{
	return (num != num);
}

template <typename Tx>
bool CppTools::CTMath::CTCalculate<Tx>::checkNaN(const Tx num)
{
	if(isNaN(num))
#ifndef CCU_SURPORT
		throw CppTools::CTException::CTDataException::CTDataNotANumber();
#else
		return true;
#endif
	else
		return false;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::angle2Radian(Tx angle)
{
	return angle * (Tx)CT_PI / (Tx)180.0;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::radian2Angle(Tx radian)
{
	return radian * (Tx)180.0 / (Tx)CT_PI;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::sumOf(int n, ...)
{
	Tx s = 0;
	int i;
	va_list argp;
	va_start(argp, n);
	for(i = 0; i < n; ++i)
		s += CppTools::CTData::CTDataFunc<Tx>::va_arg_in(&argp);
	va_end(argp);
	return s;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::sumOfSquares(Tx a, Tx b)
{
	return Pow2<Tx>(a) + Pow2<Tx>(b);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::difOfSquares(Tx a, Tx b)
{
	return Pow2<Tx>(a) - Pow2<Tx>(b);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::compleAngle(Tx angle)
{
	if(angle < 0)
	{
		compleAngle(-angle);
	}
	else if(angle > (Tx)CT_PI_2)
	{
		compleAngle(angle - (Tx)CT_PI_2);
	}
	return (Tx)CT_PI_2 - angle;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::suppleAngle(Tx angle)
{
	if(angle < 0)
	{
		suppleAngle(-angle);
	}
	else if(angle > (Tx)CT_PI)
	{
		suppleAngle(angle - (Tx)CT_PI);
	}
	return (Tx)CT_PI - angle;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::distance(const Tx* point3_1,
											   const Tx* point3_2)
{
	return sqrt(Pow2(point3_1[0] - point3_2[0]) + Pow2(point3_1[1] - point3_2[1]) + Pow2(point3_1[2] - point3_2[2]));
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::distance(const ct_point3& point3_1,
											   const ct_point3& point3_2)
{
	return sqrt(Pow2(point3_1.x - point3_2.x) + Pow2(point3_1.y - point3_2.y) + Pow2(point3_1.z - point3_2.z));
}

template <typename Tx>
void CppTools::CTMath::CTCalculate<Tx>::plainCenter(const point3 point_1,
												  const point3 point_2,
												  const point3 point_3,
												  point3 center_point)
{
	center_point[0] = (point_1[0] + point_2[0] + point_3[0]) / (Tx)3.0;
	center_point[1] = (point_1[1] + point_2[1] + point_3[1]) / (Tx)3.0;
	center_point[2] = (point_1[2] + point_2[2] + point_3[2]) / (Tx)3.0;
}

template <typename Tx>
void CppTools::CTMath::CTCalculate<Tx>::plainCenter(const point3 point_1,
												  const point3 point_2,
												  const point3 point_3,
												  const point3 point_4,
												  point3 center_point)
{
	center_point[0] = (point_1[0] + point_2[0] + point_3[0] + point_4[0]) / (Tx)4.0;
	center_point[1] = (point_1[1] + point_2[1] + point_3[1] + point_4[1]) / (Tx)4.0;
	center_point[2] = (point_1[2] + point_2[2] + point_3[2] + point_4[2]) / (Tx)4.0;
}


template <typename Tx> 
Tx CppTools::CTMath::CTCalculate<Tx>::Integral(const p_Tx_func_Tx func,
											   const Tx x_start,
											   const Tx x_end,
											   const int n)
{
	int i;
	Tx s = ((*func)(x_start) + (*func)(x_end)) / (Tx)2;
	Tx dh = (x_end - x_start) / n;
	for(i = 0; i < n; ++i)
		s += (*func)(x_start + dh * i);
	return (s * dh);
}

template <typename Tx> 
Tx CppTools::CTMath::CTCalculate<Tx>::Integral2d(const p_Tx_func_Tx_Tx func,
												 const Tx x_start,
												 const Tx x_end,
												 const Tx y_start,
												 const Tx y_end,
												 const int x_n,
												 const int y_n)
{
	int i, j;
	Tx s = 0, y_s;
	Tx x_dh = (x_end - x_start) / x_n;
	Tx y_dh = (y_end - y_start) / y_n;
	for(j = 0; j < y_n; ++j)
	{
		y_s = ((*func)(x_start, y_start + y_dh * j) + (*func)(x_end, y_start + y_dh * j)) / (Tx)2;
		for(i = 0; i < x_n; ++i)
		{
			y_s += (*func)(x_start + x_dh * i, y_start + y_dh * j);
		}
		s += y_s;
	}
	return (s * x_dh * y_dh);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::sumFunc(const p_Tx_func_i func,
											  const int start,
											  const Tx error)
{
	if((*func)(start) < error)
		return (Tx)(*func)(start);
	else
		return (*func)(start) + sumFunc(func, start + 1, error);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::factorial(const UINT n)
{
	if (!n)
		return (Tx)1;
	else
		return (Tx)n * factorial(n - 1);
}

template <typename Tx>
bool CppTools::CTMath::CTCalculate<Tx>::isEqual(const Tx a,
												const Tx b,
												const Tx error)
{
	if(a == b) return true;
	Tx sub = Abs<Tx>(a - b);
	if(sub < error || (sub / Max<Tx>(abs(a), abs(b))) < error)
		return true;
	return false;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::maxOf(const Tx* data,
											const int n)
{
	if (n <= 0)
		return 0;
	Tx maxv = data[0];
	int i;
	for(i = 1; i < n; ++i)
	{
		if(data[i] > maxv)
		{
			maxv = data[i];
		}
	}
	return maxv;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::minOf(const Tx *data,
											const int n)
{
	if (n <= 0)
		return 0;
	Tx minv = data[0];
	int i;
	for(i = 1; i < n; ++i)
	{
		if(data[i] < minv)
		{
			minv = data[i];
		}
	}
	return minv;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::sumOf(const Tx *data,
											const int n)
{
	if (n <= 0)
		return 0;
	Tx sumv = data[0];
	int i;
	for(i = 1; i < n; ++i)
	{
		sumv += data[i];
	}
	return sumv;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::averageOf(const Tx *data,
												const int n)
{
	return sumOf(data, n) / n;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::stdDeviationOf(const Tx* data,
													 const int n)
{
	return sqrt(varianceOf(data, n) / n);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::stdErrorOf(const Tx* data,
												 const Tx true_value,
												 const int n)
{
	if(n <= 0)
		return 0;
	Tx sumv = 0;
	int i;
	for(i = 0; i < n; ++i);
	{
		sumv += Pow2(data[i] - true_value);
	}
	return sqrt(sumv / (n - 1));
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::varianceOf(const Tx* data,
												 const int n)
{
	if(n <= 0)
		return 0;
	Tx avg = averageOf(data, n);
	Tx sumv = 0;
	int i;
	for(i = 0; i < n; ++i);
	{
		sumv += Pow2(data[i] - avg);
	}
	return sumv;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::squareOf(const Tx *data,
											   const int n)
{
	if(n <= 0)
		return 0;
	Tx sumv;
	int i;
	for(i = 0; i < n; ++i)
	{
		sumv += Pow2(data[i]);
	}
	return sumv;
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::rootMeanSquareOf(const Tx *data,
													   const int n)
{
	return sqrt(squareOf(data, n) / n);
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::steradian(const Tx area_on_sphere,
												const Tx radius)
{
	return (area_on_sphere / Pow2(radius));
}

template <typename Tx>
Tx CppTools::CTMath::CTCalculate<Tx>::areaOnSphere(const Tx steradian,
												   const Tx radius)
{
	return (steradian * Pow2(radius));
}