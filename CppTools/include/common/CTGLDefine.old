#pragma once

#ifndef CTGLDEFINE_H
#define CTGLDEFINE_H

#define CTGL_VER   1

#include <GL/gl.h>
#include <GL/glu.h>
#include <CTBase>

#include "windows.h"
#pragma comment (lib, "winmm.lib")
#pragma comment(lib, "ctcore.lib")

typedef GLuint CTDisplayMode;

typedef GLuint CTTexture;
typedef GLuint CTMask;

typedef GLuint CTImageDatau;
typedef GLint CTImageDatai;
typedef GLuint CTImageMode;

typedef PIXELFORMATDESCRIPTOR CTPfd;

typedef GLuint CTGLHandle;

typedef char GLchar;

namespace CppTools
{
	namespace CTGL
	{
		typedef enum CPPTOOLS_TYPE_API _CTGLEnum
		{
			//自定义参数
			auto_mode = -1,


			//基础参数
			rgb = GL_RGB,
			rgba = GL_RGBA,
			bgr = GL_BGR_EXT,
			bgra = GL_BGRA_EXT,

			gl_version = GL_VERSION,

			color_buffer = GL_COLOR_BUFFER_BIT,
			depth_buffer = GL_DEPTH_BUFFER_BIT,

			depth_test = GL_DEPTH_TEST,
			alpha_test = GL_ALPHA_TEST,

			//纹理设置参数
			texture_1d = GL_TEXTURE_1D,
			texture_2d = GL_TEXTURE_2D,
			blend = GL_BLEND,

			//纹理混合模式
			zero = GL_ZERO,
			one = GL_ONE,
			src_a = GL_SRC_ALPHA,
			dst_a = GL_DST_ALPHA,
			src_color = GL_SRC_COLOR,
			dst_color = GL_DST_COLOR,
			one_src_a = GL_ONE_MINUS_SRC_ALPHA,
			one_dst_a = GL_ONE_MINUS_DST_ALPHA,

			//纹理使用参数
			unpack = GL_UNPACK_ALIGNMENT,

			wrap_s = GL_TEXTURE_WRAP_S,
			wrap_t = GL_TEXTURE_WRAP_T,

			clamp = GL_CLAMP,
			repeat = GL_REPEAT,

			mag_filter = GL_TEXTURE_MAG_FILTER,						//nearest linear
			min_filter = GL_TEXTURE_MIN_FILTER,						//nearest linear 等

			nearest = GL_NEAREST,									//点采样
			linear = GL_LINEAR,										//双线性采样
			nearest_mipmap_nearest = GL_NEAREST_MIPMAP_NEAREST,
			nearest_mipmap_linear = GL_NEAREST_MIPMAP_LINEAR,
			linear_mipmap_nearest = GL_LINEAR_MIPMAP_NEAREST,
			linear_mipmap_linear = GL_LINEAR_MIPMAP_LINEAR,			//三线性采样

			light = GL_LIGHTING,
		} CTGLEnum;

		//glBegin、ctglStart的参数
		typedef enum CPPTOOLS_TYPE_API _CTGLShapeEnum
		{
			gl_points = GL_POINTS,					//单个点
			gl_lines = GL_LINES,					//一对顶点被解释成直线
			gl_lines_s = GL_LINE_STRIP,				//顶点连成直线
			gl_lines_l = GL_LINE_LOOP,				//顶点连成直线，并且首末顶点相连
			gl_triangles = GL_TRIANGLES,			//3个顶点被解释成三角形
			gl_triangles_s = GL_TRIANGLE_STRIP,		//按逆时针顺序，依次连接的三角形串
			gl_triangles_f = GL_TRIANGLE_FAN,		//共享第一个顶点的三角形串
			gl_quads = GL_QUADS,					//4个顶点被解释成四边形
			gl_quads_s = GL_QUAD_STRIP,				//按逆时针顺序，依次连接的四边形串
			gl_polygon = GL_POLYGON,				//多边形，必须是n>=3，凸多边形
		} CTGLShapeEnum;

		typedef enum CPPTOOLS_TYPE_API _CTGLLightEnum
		{
			light0 = GL_LIGHT0,
			light1 = GL_LIGHT1,
			light2 = GL_LIGHT2,
			light3 = GL_LIGHT3,
			light4 = GL_LIGHT4,
			light5 = GL_LIGHT5,
			light6 = GL_LIGHT6,
			light7 = GL_LIGHT7,
		} CTGLLightEnum;

		typedef enum CPPTOOLS_TYPE_API _CTGLFaceEnum
		{
			gl_front = GL_FRONT,
			gl_back = GL_BACK,
			gl_front_back = GL_FRONT_AND_BACK,
		} CTGLFaceEnum;

		typedef enum CPPTOOLS_TYPE_API _CTGLDataTypeEnum
		{
			gl_short = GL_SHORT,
			gl_int = GL_INT,
			gl_float = GL_FLOAT,
			gl_double = GL_DOUBLE,

			gl_byte = GL_BYTE,
			gl_ubyte = GL_UNSIGNED_BYTE,
			gl_ushort = GL_UNSIGNED_SHORT,
			gl_uint = GL_UNSIGNED_INT,
		} CTGLDataTypeEnum;

		//定义辅助数据类型
		template<typename Tx>
		struct CPPTOOLS_TYPE_API color3
		{
			color3(const Tx& r = 0, const Tx& g = 0, const Tx& b = 0)
				: red(r), green(g), blue(b)
			{
			}
			Tx red, green, blue;
		};

		typedef color3<GLubyte>		color3u;
		typedef color3<GLint>		color3i;
		typedef color3<GLfloat>		color3f;
		typedef color3<GLdouble>	color3d;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API color3list
		{
			color3<Tx> left_top, left_bottom, right_top, right_bottom;
		};

		typedef color3list<GLubyte>		color3ulist;
		typedef color3list<GLint>		color3ilist;
		typedef color3list<GLfloat>		color3flist;
		typedef color3list<GLdouble>	color3dlist;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API color4
		{
			color4(const Tx& r = 0, const Tx& g = 0, const Tx& b = 0, const Tx& a = 0)
				: red(r), green(g), blue(b), alpha(a)
			{
			}
			Tx red, green, blue, alpha;
		};

		typedef color4<GLubyte>		color4u;
		typedef color4<GLint>		color4i;
		typedef color4<GLfloat>		color4f;
		typedef color4<GLdouble>	color4d;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API point2
		{
			point2(const Tx& x = 0, const Tx& y = 0)
				: x(x), y(y)
			{
			}
			Tx x, y;
		};

		typedef point2<GLubyte>		point2u;
		typedef point2<GLint>		point2i;
		typedef point2<GLfloat>		point2f;
		typedef point2<GLdouble>	point2d;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API size2
		{
			size2(const Tx& w = 0, const Tx& h = 0)
				: w(w), h(h)
			{
			}
			Tx w, h;
		};

		typedef size2<GLubyte>		size2u;
		typedef size2<GLint>		size2i;
		typedef size2<GLfloat>		size2f;
		typedef size2<GLdouble>		size2d;

		typedef point2i				glPos;
		typedef size2i				glSize;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API point3
		{
			point3(const Tx& x = 0, const Tx& y = 0, const Tx& z = 0)
				: x(x), y(y), z(z)
			{
			}
			Tx x, y, z;
		};

		typedef point3<GLubyte>		point3u;
		typedef point3<GLint>		point3i;
		typedef point3<GLfloat>		point3f;
		typedef point3<GLdouble>	point3d;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API rect2
		{
			point2<Tx> left, right;
		};

		typedef rect2<GLubyte>		rect2u;
		typedef rect2<GLint>		rect2i;
		typedef rect2<GLfloat>		rect2f;
		typedef rect2<GLdouble>		rect2d;

		template<typename Tx>
		struct CPPTOOLS_TYPE_API rect3
		{
			point3<Tx> left_top, left_bottom, right_top, right_bottom;
		};

		typedef rect3<GLubyte>		rect3u;
		typedef rect3<GLint>		rect3i;
		typedef rect3<GLfloat>		rect3f;
		typedef rect3<GLdouble>		rect3d;

		//封装的颜色
		namespace CTColor
		{
			static const color3d Black(0.0, 0.0, 0.0);
			static const color3d Red(1.0, 0.0, 0.0);
			static const color3d Green(0.0, 1.0, 0.0);
			static const color3d Blue(0.0, 0.0, 1.0);
			static const color3d Yellow(1.0, 1.0, 0.0);
			static const color3d Violet(1.0, 0.0, 1.0);
			static const color3d Cyan(0.0, 1.0, 1.0);
			static const color3d White(1.0, 1.0, 1.0);
		};

		//封装的OpenGL函数
		CPPTOOLS_INLINEFUNC_API inline const GLubyte* ctglVer()
		{
			return glGetString(gl_version);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglCls()
		{
			glClear(color_buffer);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglClsd()
		{
			glClear(color_buffer | depth_buffer);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglClColor()
		{
			glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglUse(CTGLEnum state)
		{
			glEnable(state);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglDisuse(CTGLEnum state)
		{
			glDisable(state);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglStart(CTGLShapeEnum shape)
		{
			glBegin(shape);
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglEnd()
		{
			glEnd();
		}		

		CPPTOOLS_INLINEFUNC_API inline void ctglClMatrix()
		{
			glLoadIdentity();
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglSMatrix()
		{
			glPushMatrix();
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglLMatrix()
		{
			glPopMatrix();
		}

		CPPTOOLS_INLINEFUNC_API inline void ctglFlush()
		{
			glFlush();
		}

		//CT扩展的函数
		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer2(Tx** point, GLint position, Tx x, Tx y)
		{
			point[position][0] = x;
			point[position][1] = y;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer2(Tx* point, GLint position, Tx x, Tx y)
		{
			point[position * 2] = x;
			point[position * 2 + 1] = y;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer2(Tx* point, Tx x, Tx y)
		{
			point[0] = x;
			point[1] = y;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer3(Tx** point, GLint position, Tx x, Tx y, Tx z)
		{
			point[position][0] = x;
			point[position][1] = y;
			point[position][2] = z;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer3(Tx* point, GLint position, Tx x, Tx y, Tx z)
		{
			point[position * 3] = x;
			point[position * 3 + 1] = y;
			point[position * 3 + 2] = z;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer3(Tx* point, Tx x, Tx y, Tx z)
		{
			point[0] = x;
			point[1] = y;
			point[2] = z;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer4(Tx** point, GLint position, Tx x, Tx y, Tx z, Tx a)
		{
			point[position][0] = x;
			point[position][1] = y;
			point[position][2] = z;
			point[position][3] = a;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer4(Tx* point, GLint position, Tx x, Tx y, Tx z, Tx a)
		{
			point[position * 4] = x;
			point[position * 4 + 1] = y;
			point[position * 4 + 2] = z;
			point[position * 4 + 3] = a;
		}

		template<typename Tx>
		CPPTOOLS_TFUNC_API inline void ctglSetPointer4(Tx* point, Tx x, Tx y, Tx z, Tx a)
		{
			point[0] = x;
			point[1] = y;
			point[2] = z;
			point[3] = a;
		}
	}
}

#endif